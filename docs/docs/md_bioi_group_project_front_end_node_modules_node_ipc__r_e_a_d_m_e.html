<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vaccine Dashboard: node-ipc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vaccine Dashboard
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_bioi_group_project_front_end_node_modules_node_ipc__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">node-ipc </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>a nodejs module for local and remote Inter Process Communication</em> with full support for Linux, Mac and Windows. It also supports all forms of socket communication from low level unix and windows sockets to UDP and secure TLS and TCP sockets.</p>
<p>A great solution for complex multiprocess <b>Neural Networking</b> in Node.JS</p>
<p><b>npm install node-ipc</b></p>
<h3><a class="anchor" id="autotoc_md22520"></a>
NPM Stats</h3>
<p>npm info : <a href="http://npm-stat.com/charts.html?package=node-ipc&amp;author=&amp;from=&amp;to=">See npm trends and stats for node-ipc</a> <br  />
 <a href="https://nodei.co/npm/node-ipc/"><img src="https://nodei.co/npm/node-ipc.png?downloads=true&amp;downloadRank=true&amp;stars=true" alt="NPM" class="inline"/></a> <a href="http://packagequality.com/#?package=node-ipc"><img src="http://npm.packagequality.com/badge/node-ipc.png" alt="Package Quality" class="inline"/></a> <br  />
 <img src="https://img.shields.io/npm/v/node-ipc.svg" alt="node-ipc npm version" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/node/v/node-ipc.svg" alt="supported node version for node-ipc" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/npm/dt/node-ipc.svg" alt="total npm downloads for node-ipc" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/npm/dm/node-ipc.svg" alt="monthly npm downloads for node-ipc" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/npm/l/node-ipc.svg" alt="npm licence for node-ipc" style="pointer-events: none;" class="inline"/></p>
<p><a href="https://github.com/RIAEvangelist"><img src="https://avatars3.githubusercontent.com/u/369041?v=3&amp;s=100" alt="RIAEvangelist" class="inline"/></a></p>
<p>GitHub info : <br  />
 <img src="https://img.shields.io/github/release/RIAEvangelist/node-ipc.svg" alt="node-ipc GitHub Release" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/github/license/RIAEvangelist/node-ipc.svg" alt="GitHub license node-ipc license" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/github/issues/RIAEvangelist/node-ipc.svg" alt="open issues for node-ipc on GitHub" style="pointer-events: none;" class="inline"/></p>
<p>Codacy info : <br  />
 <a href="https://www.codacy.com/app/RIAEvangelist/node-ipc"><img src="https://api.codacy.com/project/badge/grade/8e0294dff55f4ac1985c07b16f39d0a9" alt="Codacy Badge" class="inline"/></a> <a href="https://www.codacy.com/app/RIAEvangelist/node-ipc"><img src="https://api.codacy.com/project/badge/coverage/8e0294dff55f4ac1985c07b16f39d0a9" alt="Codacy Badge" class="inline"/></a></p>
<p>Build Info : <br  />
 Mac &amp; Linux : <a href="https://travis-ci.org/RIAEvangelist/node-ipc"><img src="https://travis-ci.org/RIAEvangelist/node-ipc.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a> Windows : <a href="https://ci.appveyor.com/project/RIAEvangelist/node-ipc/history"><img src="https://ci.appveyor.com/api/projects/status/github/riaevangelist/node-ipc?branch=master&amp;svg=true" alt="node-ipc windows build status" class="inline"/></a></p>
<p>Package details websites :</p><ul>
<li><a href="http://riaevangelist.github.io/node-ipc/" title="node-ipc documentation">GitHub.io site</a>. A prettier version of this site.</li>
<li><a href="https://www.npmjs.org/package/node-ipc" title="node-ipc npm module">NPM Module</a>. The npm page for the node-ipc module.</li>
</ul>
<p>This work is licenced via the MIT Licence.</p>
<h3><a class="anchor" id="autotoc_md22521"></a>
Older versions of node</h3>
<p>the latest versions of <code>node-ipc</code> may work with the &ndash;harmony flag. Officially though, we support node v4 and newer with es5 and es6</p>
<h3><a class="anchor" id="autotoc_md22522"></a>
Testing</h3>
<p><code>npm test</code> will run the jasmine tests with istanbul for node-ipc and generate a coverage report in the spec folder.</p>
<p>You may want to install jasmine and istanbul globally with <code>sudo npm install -g jasmine istanbul</code></p>
<hr  />
 <h3><a class="anchor" id="autotoc_md22524"></a>
Contents</h3>
<ol type="1">
<li><a href="#types-of-ipc-sockets">Types of IPC Sockets and Supporting OS</a></li>
</ol>
<ol type="1">
<li><a href="#ipc-config">IPC Config</a></li>
<li><a href="#ipc-methods">IPC Methods</a><ol type="a">
<li><a href="#log">log</a></li>
<li><a href="#connectto">connectTo</a></li>
<li><a href="#connecttonet">connectToNet</a></li>
<li><a href="#disconnect">disconnect</a></li>
<li><a href="#serve">serve</a></li>
<li><a href="#servenet">serveNet</a></li>
</ol>
</li>
<li><a href="#ipc-stores-and-default-variables">IPC Stores and Default Variables</a></li>
<li><a href="#ipc-events">IPC Events</a></li>
<li><a href="#multiple-ipc-instances">Multiple IPC instances</a></li>
<li><a href="#basic-examples">Basic Examples</a><ol type="a">
<li><a href="#server-for-unix-sockets--tcp-sockets">Server for Unix||Windows Sockets &amp; TCP Sockets</a></li>
<li><a href="#client-for-unix-sockets--tcp-sockets">Client for Unix||Windows Sockets &amp; TCP Sockets</a></li>
<li><a href="#server--client-for-udp-sockets">Server &amp; Client for UDP Sockets</a></li>
<li><a href="#raw-buffer-or-binary-sockets">Raw Buffers, Real Time and / or Binary Sockets</a></li>
</ol>
</li>
<li><a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/TLSSocket">Working with TLS/SSL Socket Servers &amp; Clients</a></li>
<li><a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example">Node Code Examples</a></li>
</ol>
<hr  />
 <h3><a class="anchor" id="autotoc_md22526"></a>
Types of IPC Sockets</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Stability   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unix Socket or Windows Socket   </td><td class="markdownTableBodyNone">Stable   </td><td class="markdownTableBodyNone">Gives Linux, Mac, and Windows lightning fast communication and avoids the network card to reduce overhead and latency. <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/unixWindowsSocket/" title="Unix and Windows Socket Node IPC examples">Local Unix and Windows Socket examples</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TCP Socket   </td><td class="markdownTableBodyNone">Stable   </td><td class="markdownTableBodyNone">Gives the most reliable communication across the network. Can be used for local IPC as well, but is slower than #1's Unix Socket Implementation because TCP sockets go through the network card while Unix Sockets and Windows Sockets do not. <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/TCPSocket/" title="TCP Socket Node IPC examples">Local or remote network TCP Socket examples</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TLS Socket   </td><td class="markdownTableBodyNone">Stable   </td><td class="markdownTableBodyNone">Configurable and secure network socket over SSL. Equivalent to https. <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/TLSSocket">TLS/SSL documentation</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UDP Sockets   </td><td class="markdownTableBodyNone">Stable   </td><td class="markdownTableBodyNone">Gives the <b>fastest network communication</b>. UDP is less reliable but much faster than TCP. It is best used for streaming non critical data like sound, video, or multiplayer game data as it can drop packets depending on network connectivity and other factors. UDP can be used for local IPC as well, but is slower than #1's Unix Socket or Windows Socket Implementation because UDP sockets go through the network card while Unix and Windows Sockets do not. <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/UDPSocket/" title="UDP Socket Node IPC examples">Local or remote network UDP Socket examples</a>   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">OS   </th><th class="markdownTableHeadNone">Supported Sockets    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone">Unix, Posix, TCP, TLS, UDP    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Mac   </td><td class="markdownTableBodyNone">Unix, Posix, TCP, TLS, UDP    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Win   </td><td class="markdownTableBodyNone">Windows, TCP, TLS, UDP   </td></tr>
</table>
<hr  />
<h3><a class="anchor" id="autotoc_md22528"></a>
IPC Config</h3>
<p><code>ipc.config</code> <br  />
</p>
<p>Set these variables in the <code>ipc.config</code> scope to overwrite or set default values.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    appspace        : &#39;app.&#39;,</div>
<div class="line">    socketRoot      : &#39;/tmp/&#39;,</div>
<div class="line">    id              : os.hostname(),</div>
<div class="line">    networkHost     : &#39;localhost&#39;, //should resolve to 127.0.0.1 or ::1 see the table below related to this</div>
<div class="line">    networkPort     : 8000,</div>
<div class="line">    encoding        : &#39;utf8&#39;,</div>
<div class="line">    rawBuffer       : false,</div>
<div class="line">    delimiter       : &#39;\f&#39;,</div>
<div class="line">    sync            : false,</div>
<div class="line">    silent          : false,</div>
<div class="line">    logInColor      : true,</div>
<div class="line">    logDepth        : 5,</div>
<div class="line">    logger          : console.log,</div>
<div class="line">    maxConnections  : 100,</div>
<div class="line">    retry           : 500,</div>
<div class="line">    maxRetries      : false,</div>
<div class="line">    stopRetrying    : false,</div>
<div class="line">    unlink          : true,</div>
<div class="line">    interfaces      : {</div>
<div class="line">        localAddress: false,</div>
<div class="line">        localPort   : false,</div>
<div class="line">        family      : false,</div>
<div class="line">        hints       : false,</div>
<div class="line">        lookup      : false</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">variable   </th><th class="markdownTableHeadNone">documentation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">appspace   </td><td class="markdownTableBodyNone">used for Unix Socket (Unix Domain Socket) namespacing. If not set specifically, the Unix Domain Socket will combine the socketRoot, appspace, and id to form the Unix Socket Path for creation or binding. This is available in case you have many apps running on your system, you may have several sockets with the same id, but if you change the appspace, you will still have app specic unique sockets.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">socketRoot   </td><td class="markdownTableBodyNone">the directory in which to create or bind to a Unix Socket    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">id   </td><td class="markdownTableBodyNone">the id of this socket or service    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">networkHost   </td><td class="markdownTableBodyNone">the local or remote host on which TCP, TLS or UDP Sockets should connect    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">networkPort   </td><td class="markdownTableBodyNone">the default port on which TCP, TLS, or UDP sockets should connect    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">encoding   </td><td class="markdownTableBodyNone">the default encoding for data sent on sockets. Mostly used if rawBuffer is set to true. Valid values are : <code>ascii</code> <code>utf8</code> <code>utf16le</code> <code>ucs2</code> <code>base64</code> <code>hex</code> .    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rawBuffer   </td><td class="markdownTableBodyNone">if true, data will be sent and received as a raw node <code>Buffer</code> <b>NOT</b> an <code>Object</code> as JSON. This is great for Binary or hex IPC, and communicating with other processes in languages like C and C++    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">delimiter   </td><td class="markdownTableBodyNone">the delimiter at the end of each data packet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sync   </td><td class="markdownTableBodyNone">synchronous requests. Clients will not send new requests until the server answers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">silent   </td><td class="markdownTableBodyNone">turn on/off logging default is false which means logging is on    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">logInColor   </td><td class="markdownTableBodyNone">turn on/off util.inspect colors for ipc.log    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">logDepth   </td><td class="markdownTableBodyNone">set the depth for util.inspect during ipc.log    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">logger   </td><td class="markdownTableBodyNone">the function which receives the output from ipc.log; should take a single string argument    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">maxConnections   </td><td class="markdownTableBodyNone">this is the max number of connections allowed to a socket. It is currently only being set on Unix Sockets. Other Socket types are using the system defaults.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">retry   </td><td class="markdownTableBodyNone">this is the time in milliseconds a client will wait before trying to reconnect to a server if the connection is lost. This does not effect UDP sockets since they do not have a client server relationship like Unix Sockets and TCP Sockets.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">maxRetries   </td><td class="markdownTableBodyNone">if set, it represents the maximum number of retries after each disconnect before giving up and completely killing a specific connection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">stopRetrying   </td><td class="markdownTableBodyNone">Defaults to false meaning clients will continue to retry to connect to servers indefinitely at the retry interval. If set to any number the client will stop retrying when that number is exceeded after each disconnect. If set to true in real time it will immediately stop trying to connect regardless of maxRetries. If set to 0, the client will <em><b>NOT</b></em> try to reconnect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unlink   </td><td class="markdownTableBodyNone">Defaults to true meaning that the module will take care of deleting the IPC socket prior to startup. If you use <code>node-ipc</code> in a clustered environment where there will be multiple listeners on the same socket, you must set this to <code>false</code> and then take care of deleting the socket in your own code.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">interfaces   </td><td class="markdownTableBodyNone">primarily used when specifying which interface a client should connect through. see the <a href="https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener">socket.connect documentation in the node.js api</a>   </td></tr>
</table>
<hr  />
<h3><a class="anchor" id="autotoc_md22530"></a>
IPC Methods</h3>
<p>These methods are available in the IPC Scope. <br  />
</p>
<hr  />
 <h4><a class="anchor" id="autotoc_md22532"></a>
log</h4>
<p><code>ipc.log(a,b,c,d,e...);</code> <br  />
</p>
<p>ipc.log will accept any number of arguments and if <code>ipc.config.silent</code> is not set, it will concat them all with a single space ' ' between them and then log them to the console. This is fast because it prevents any concatenation from happening if the ipc.config.silent is set <code>true</code>. That way if you leave your logging in place it should have almost no effect on performance.</p>
<p>The log also uses util.inspect You can control if it should log in color, the log depth, and the destination via <code>ipc.config</code></p>
<div class="fragment"><div class="line">ipc.config.logInColor=true; //default</div>
<div class="line">ipc.config.logDepth=5; //default    </div>
<div class="line">ipc.config.logger=console.log.bind(console); // default</div>
</div><!-- fragment --><hr  />
 <h4><a class="anchor" id="autotoc_md22534"></a>
connectTo</h4>
<p><code>ipc.connectTo(id,path,callback);</code> <br  />
</p>
<p>Used for connecting as a client to local Unix Sockets and Windows Sockets. <em><b>This is the fastest way for processes on the same machine to communicate</b></em> because it bypasses the network card which TCP and UDP must both use.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">variable   </th><th class="markdownTableHeadNone">required   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">id   </td><td class="markdownTableBodyNone">required   </td><td class="markdownTableBodyNone">is the string id of the socket being connected to. The socket with this id is added to the ipc.of object when created.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">path   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">is the path of the Unix Domain Socket File, if the System is Windows, this will automatically be converted to an appropriate pipe with the same information as the Unix Domain Socket File. If not set this will default to <code>ipc.config.socketRoot</code>+<code>ipc.config.appspace</code>+<code>id</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">callback   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">this is the function to execute when the socket has been created.   </td></tr>
</table>
<p><b>examples</b> arguments can be ommitted so long as they are still in order.</p>
<div class="fragment"><div class="line">ipc.connectTo(&#39;world&#39;);</div>
</div><!-- fragment --><p>or using just an id and a callback</p>
<div class="fragment"><div class="line">ipc.connectTo(</div>
<div class="line">    &#39;world&#39;,</div>
<div class="line">    function(){</div>
<div class="line">        ipc.of.world.on(</div>
<div class="line">            &#39;hello&#39;,</div>
<div class="line">            function(data){</div>
<div class="line">                ipc.log(data.debug);</div>
<div class="line">                //if data was a string, it would have the color set to the debug style applied to it</div>
<div class="line">            }</div>
<div class="line">        )</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><p>or explicitly setting the path</p>
<div class="fragment"><div class="line">ipc.connectTo(</div>
<div class="line">    &#39;world&#39;,</div>
<div class="line">    &#39;myapp.world&#39;</div>
<div class="line">);</div>
</div><!-- fragment --><p>or explicitly setting the path with callback</p>
<div class="fragment"><div class="line">ipc.connectTo(</div>
<div class="line">    &#39;world&#39;,</div>
<div class="line">    &#39;myapp.world&#39;,</div>
<div class="line">    function(){</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
 <h4><a class="anchor" id="autotoc_md22536"></a>
connectToNet</h4>
<p><code>ipc.connectToNet(id,host,port,callback)</code> <br  />
</p>
<p>Used to connect as a client to a TCP or <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/TLSSocket">TLS socket</a> via the network card. This can be local or remote, if local, it is recommended that you use the Unix and Windows Socket Implementaion of <code>connectTo</code> instead as it is much faster since it avoids the network card altogether.</p>
<p>For TLS and SSL Sockets see the <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/TLSSocket">node-ipc TLS and SSL docs</a>. They have a few additional requirements, and things to know about and so have their own doc.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">variable   </th><th class="markdownTableHeadNone">required   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">id   </td><td class="markdownTableBodyNone">required   </td><td class="markdownTableBodyNone">is the string id of the socket being connected to. For TCP &amp; TLS sockets, this id is added to the <code>ipc.of</code> object when the socket is created with a reference to the socket.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">host   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">is the host on which the TCP or TLS socket resides. This will default to <code>ipc.config.networkHost</code> if not specified.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">port   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">the port on which the TCP or TLS socket resides.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">callback   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">this is the function to execute when the socket has been created.   </td></tr>
</table>
<p><b>examples</b> arguments can be ommitted so long as they are still in order. <br  />
 So while the default is : (id,host,port,callback), the following examples will still work because they are still in order (id,port,callback) or (id,host,callback) or (id,port) etc.</p>
<div class="fragment"><div class="line">ipc.connectToNet(&#39;world&#39;);</div>
</div><!-- fragment --><p>or using just an id and a callback</p>
<div class="fragment"><div class="line">ipc.connectToNet(</div>
<div class="line">    &#39;world&#39;,</div>
<div class="line">    function(){</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><p>or explicitly setting the host and path</p>
<div class="fragment"><div class="line">ipc.connectToNet(</div>
<div class="line">    &#39;world&#39;,</div>
<div class="line">    &#39;myapp.com&#39;,serve(path,callback)</div>
<div class="line">    3435</div>
<div class="line">);</div>
</div><!-- fragment --><p>or only explicitly setting port and callback</p>
<div class="fragment"><div class="line">ipc.connectToNet(</div>
<div class="line">    &#39;world&#39;,</div>
<div class="line">    3435,</div>
<div class="line">    function(){</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
 <h4><a class="anchor" id="autotoc_md22538"></a>
disconnect</h4>
<p><code>ipc.disconnect(id)</code> <br  />
</p>
<p>Used to disconnect a client from a Unix, Windows, TCP or TLS socket. The socket and its refrence will be removed from memory and the <code>ipc.of</code> scope. This can be local or remote. UDP clients do not maintain connections and so there are no Clients and this method has no value to them.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">variable   </th><th class="markdownTableHeadNone">required   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">id   </td><td class="markdownTableBodyNone">required   </td><td class="markdownTableBodyNone">is the string id of the socket from which to disconnect.   </td></tr>
</table>
<p><b>examples</b></p>
<div class="fragment"><div class="line">ipc.disconnect(&#39;world&#39;);</div>
</div><!-- fragment --><hr  />
 <h4><a class="anchor" id="autotoc_md22540"></a>
serve</h4>
<p><code>ipc.serve(path,callback);</code> <br  />
</p>
<p>Used to create local Unix Socket Server or Windows Socket Server to which Clients can bind. The server can <code>emit</code> events to specific Client Sockets, or <code>broadcast</code> events to all known Client Sockets. <br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">variable   </th><th class="markdownTableHeadNone">required   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">path   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">This is the path of the Unix Domain Socket File, if the System is Windows, this will automatically be converted to an appropriate pipe with the same information as the Unix Domain Socket File. If not set this will default to <code>ipc.config.socketRoot</code>+<code>ipc.config.appspace</code>+<code>id</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">callback   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">This is a function to be called after the Server has started. This can also be done by binding an event to the start event like &lsquo;ipc.server.on('start&rsquo;,function(){});`   </td></tr>
</table>
<p><em><b>examples</b></em> arguments can be omitted so long as they are still in order.</p>
<div class="fragment"><div class="line">ipc.serve();</div>
</div><!-- fragment --><p>or specifying callback</p>
<div class="fragment"><div class="line">ipc.serve(</div>
<div class="line">    function(){...}</div>
<div class="line">);</div>
</div><!-- fragment --><p>or specify path</p>
<div class="fragment"><div class="line">ipc.serve(</div>
<div class="line">    &#39;/tmp/myapp.myservice&#39;</div>
<div class="line">);</div>
</div><!-- fragment --><p>or specifying everything</p>
<div class="fragment"><div class="line">ipc.serve(</div>
<div class="line">    &#39;/tmp/myapp.myservice&#39;,</div>
<div class="line">    function(){...}</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
 <h4><a class="anchor" id="autotoc_md22542"></a>
serveNet</h4>
<p><code>serveNet(host,port,UDPType,callback)</code></p>
<p>Used to create TCP, TLS or UDP Socket Server to which Clients can bind or other servers can send data to. The server can <code>emit</code> events to specific Client Sockets, or <code>broadcast</code> events to all known Client Sockets.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">variable   </th><th class="markdownTableHeadNone">required   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">host   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">If not specified this defaults to the first address in os.networkInterfaces(). For TCP, TLS &amp; UDP servers this is most likely going to be 127.0.0.1 or ::1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">port   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">The port on which the TCP, UDP, or TLS Socket server will be bound, this defaults to 8000 if not specified    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">UDPType   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">If set this will create the server as a UDP socket. 'udp4' or 'udp6' are valid values. This defaults to not being set. When using udp6 make sure to specify a valid IPv6 host, like <code>::1</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">callback   </td><td class="markdownTableBodyNone">optional   </td><td class="markdownTableBodyNone">Function to be called when the server is created   </td></tr>
</table>
<p><em><b>examples</b></em> arguments can be ommitted solong as they are still in order.</p>
<p>default tcp server</p>
<div class="fragment"><div class="line">ipc.serveNet();</div>
</div><!-- fragment --><p>default udp server</p>
<div class="fragment"><div class="line">ipc.serveNet(&#39;udp4&#39;);</div>
</div><!-- fragment --><p>or specifying TCP server with callback</p>
<div class="fragment"><div class="line">ipc.serveNet(</div>
<div class="line">    function(){...}</div>
<div class="line">);</div>
</div><!-- fragment --><p>or specifying UDP server with callback</p>
<div class="fragment"><div class="line">ipc.serveNet(</div>
<div class="line">    &#39;udp4&#39;,</div>
<div class="line">    function(){...}</div>
<div class="line">);</div>
</div><!-- fragment --><p>or specify port</p>
<div class="fragment"><div class="line">ipc.serveNet(</div>
<div class="line">    3435</div>
<div class="line">);</div>
</div><!-- fragment --><p>or specifying everything TCP</p>
<div class="fragment"><div class="line">ipc.serveNet(</div>
<div class="line">    &#39;MyMostAwesomeApp.com&#39;,</div>
<div class="line">    3435,</div>
<div class="line">    function(){...}</div>
<div class="line">);</div>
</div><!-- fragment --><p>or specifying everything UDP</p>
<div class="fragment"><div class="line">ipc.serveNet(</div>
<div class="line">    &#39;MyMostAwesomeApp.com&#39;,</div>
<div class="line">    3435,</div>
<div class="line">    &#39;udp4&#39;,</div>
<div class="line">    function(){...}</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md22544"></a>
IPC Stores and Default Variables</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">variable   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ipc.of   </td><td class="markdownTableBodyNone">This is where socket connection refrences will be stored when connecting to them as a client via the <code>ipc.connectTo</code> or <code>iupc.connectToNet</code>. They will be stored based on the ID used to create them, eg : ipc.of.mySocket    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ipc.server   </td><td class="markdownTableBodyNone">This is a refrence to the server created by <code>ipc.serve</code> or <code>ipc.serveNet</code>   </td></tr>
</table>
<hr  />
 <h2><a class="anchor" id="autotoc_md22546"></a>
IPC Server Methods</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">method   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">start   </td><td class="markdownTableBodyNone">start serving need to call <code>serve</code> or <code>serveNet</code> first to set up the server    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">stop   </td><td class="markdownTableBodyNone">close the server and stop serving   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md22548"></a>
IPC Events</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">event name   </th><th class="markdownTableHeadNone">params   </th><th class="markdownTableHeadNone">definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">error   </td><td class="markdownTableBodyNone">err obj   </td><td class="markdownTableBodyNone">triggered when an error has occured    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" colspan="2">connect   </td><td class="markdownTableBodyNone">triggered when socket connected    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" colspan="2">disconnect   </td><td class="markdownTableBodyNone">triggered by client when socket has disconnected from server    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">socket.disconnected   </td><td class="markdownTableBodyNone">socket destroyedSocketID   </td><td class="markdownTableBodyNone">triggered by server when a client socket has disconnected    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" colspan="2">destroy   </td><td class="markdownTableBodyNone">triggered when socket has been totally destroyed, no further auto retries will happen and all references are gone.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">data   </td><td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">triggered when ipc.config.rawBuffer is true and a message is received.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>your event type</b></em>   </td><td class="markdownTableBodyNone"><em><b>your event data</b></em>   </td><td class="markdownTableBodyNone">triggered when a JSON message is received. The event name will be the type string from your message and the param will be the data object from your message eg : &lsquo; { type:'myEvent&rsquo;,data:{a:1}} `    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" colspan="3"></td></tr>
</table>
<h2><a class="anchor" id="autotoc_md22549"></a>
Multiple IPC Instances</h2>
<p>Sometimes you might need explicit and independent instances of node-ipc. Just for such scenarios we have exposed the core IPC class on the IPC singleton.</p>
<div class="fragment"><div class="line">const RawIPC=require(&#39;node-ipc&#39;).IPC;</div>
<div class="line">const ipc=new RawIPC;</div>
<div class="line">const someOtherExplicitIPC=new RawIPC;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">//OR</div>
<div class="line"> </div>
<div class="line">const ipc=require(&#39;node-ipc&#39;);</div>
<div class="line">const someOtherExplicitIPC=new ipc.IPC;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">//setting explicit configs</div>
<div class="line"> </div>
<div class="line">//keep one silent and the other verbose</div>
<div class="line">ipc.config.silent=true;</div>
<div class="line">someOtherExplicitIPC.config.silent=true;</div>
<div class="line"> </div>
<div class="line">//make one a raw binary and the other json based ipc</div>
<div class="line">ipc.config.rawBuffer=false;</div>
<div class="line"> </div>
<div class="line">someOtherExplicitIPC.config.rawBuffer=true;</div>
<div class="line">someOtherExplicitIPC.config.encoding=&#39;hex&#39;;</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md22551"></a>
Basic Examples</h2>
<p>You can find <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example">Advanced Examples</a> in the examples folder. In the examples you will find more complex demos including multi client examples.</p>
<h3><a class="anchor" id="autotoc_md22552"></a>
Server for Unix Sockets, Windows Sockets &amp; TCP Sockets</h3>
<p>The server is the process keeping a socket for IPC open. Multiple sockets can connect to this server and talk to it. It can also broadcast to all clients or emit to a specific client. This is the most basic example which will work for local Unix and Windows Sockets as well as local or remote network TCP Sockets.</p>
<div class="fragment"><div class="line">var ipc=require(&#39;node-ipc&#39;);</div>
<div class="line"> </div>
<div class="line">ipc.config.id   = &#39;world&#39;;</div>
<div class="line">ipc.config.retry= 1500;</div>
<div class="line"> </div>
<div class="line">ipc.serve(</div>
<div class="line">    function(){</div>
<div class="line">        ipc.server.on(</div>
<div class="line">            &#39;message&#39;,</div>
<div class="line">            function(data,socket){</div>
<div class="line">                ipc.log(&#39;got a message : &#39;.debug, data);</div>
<div class="line">                ipc.server.emit(</div>
<div class="line">                    socket,</div>
<div class="line">                    &#39;message&#39;,  //this can be anything you want so long as</div>
<div class="line">                                //your client knows.</div>
<div class="line">                    data+&#39; world!&#39;</div>
<div class="line">                );</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        ipc.server.on(</div>
<div class="line">            &#39;socket.disconnected&#39;,</div>
<div class="line">            function(socket, destroyedSocketID) {</div>
<div class="line">                ipc.log(&#39;client &#39; + destroyedSocketID + &#39; has disconnected!&#39;);</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">ipc.server.start();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22553"></a>
Client for Unix Sockets &amp; TCP Sockets</h3>
<p>The client connects to the servers socket for Inter Process Communication. The socket will receive events emitted to it specifically as well as events which are broadcast out on the socket by the server. This is the most basic example which will work for both local Unix Sockets and local or remote network TCP Sockets.</p>
<div class="fragment"><div class="line">var ipc=require(&#39;node-ipc&#39;);</div>
<div class="line"> </div>
<div class="line">ipc.config.id   = &#39;hello&#39;;</div>
<div class="line">ipc.config.retry= 1500;</div>
<div class="line"> </div>
<div class="line">ipc.connectTo(</div>
<div class="line">    &#39;world&#39;,</div>
<div class="line">    function(){</div>
<div class="line">        ipc.of.world.on(</div>
<div class="line">            &#39;connect&#39;,</div>
<div class="line">            function(){</div>
<div class="line">                ipc.log(&#39;## connected to world ##&#39;.rainbow, ipc.config.delay);</div>
<div class="line">                ipc.of.world.emit(</div>
<div class="line">                    &#39;message&#39;,  //any event or message type your server listens for</div>
<div class="line">                    &#39;hello&#39;</div>
<div class="line">                )</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        ipc.of.world.on(</div>
<div class="line">            &#39;disconnect&#39;,</div>
<div class="line">            function(){</div>
<div class="line">                ipc.log(&#39;disconnected from world&#39;.notice);</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        ipc.of.world.on(</div>
<div class="line">            &#39;message&#39;,  //any event or message type your server listens for</div>
<div class="line">            function(data){</div>
<div class="line">                ipc.log(&#39;got a message from world : &#39;.debug, data);</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22554"></a>
Server &amp; Client for UDP Sockets</h3>
<p>UDP Sockets are different than Unix, Windows &amp; TCP Sockets because they must be bound to a unique port on their machine to receive messages. For example, A TCP, Unix, or Windows Socket client could just connect to a separate TCP, Unix, or Windows Socket sever. That client could then exchange, both send and receive, data on the servers port or location. UDP Sockets can not do this. They must bind to a port to receive or send data. <br  />
</p>
<p>This means a UDP Client and Server are the same thing because in order to receive data, a UDP Socket must have its own port to receive data on, and only one process can use this port at a time. It also means that in order to <code>emit</code> or <code>broadcast</code> data the UDP server will need to know the host and port of the Socket it intends to broadcast the data to.</p>
<p>This is the most basic example which will work for both local and remote UDP Sockets.</p>
<h4><a class="anchor" id="autotoc_md22555"></a>
UDP Server 1 - "World"</h4>
<div class="fragment"><div class="line">var ipc=require(&#39;../../../node-ipc&#39;);</div>
<div class="line"> </div>
<div class="line">ipc.config.id   = &#39;world&#39;;</div>
<div class="line">ipc.config.retry= 1500;</div>
<div class="line"> </div>
<div class="line">ipc.serveNet(</div>
<div class="line">    &#39;udp4&#39;,</div>
<div class="line">    function(){</div>
<div class="line">        console.log(123);</div>
<div class="line">        ipc.server.on(</div>
<div class="line">            &#39;message&#39;,</div>
<div class="line">            function(data,socket){</div>
<div class="line">                ipc.log(&#39;got a message from &#39;.debug, data.from.variable ,&#39; : &#39;.debug, data.message.variable);</div>
<div class="line">                ipc.server.emit(</div>
<div class="line">                    socket,</div>
<div class="line">                    &#39;message&#39;,</div>
<div class="line">                    {</div>
<div class="line">                        from    : ipc.config.id,</div>
<div class="line">                        message : data.message+&#39; world!&#39;</div>
<div class="line">                    }</div>
<div class="line">                );</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        console.log(ipc.server);</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">ipc.server.start();</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md22556"></a>
UDP Server 2 - "Hello"</h4>
<p><em>note</em> we set the port here to 8001 because the world server is already using the default ipc.config.networkPort of 8000. So we can not bind to 8000 while world is using it.</p>
<div class="fragment"><div class="line">ipc.config.id   = &#39;hello&#39;;</div>
<div class="line">ipc.config.retry= 1500;</div>
<div class="line"> </div>
<div class="line">ipc.serveNet(</div>
<div class="line">    8001,</div>
<div class="line">    &#39;udp4&#39;,</div>
<div class="line">    function(){</div>
<div class="line">        ipc.server.on(</div>
<div class="line">            &#39;message&#39;,</div>
<div class="line">            function(data){</div>
<div class="line">                ipc.log(&#39;got Data&#39;);</div>
<div class="line">                ipc.log(&#39;got a message from &#39;.debug, data.from.variable ,&#39; : &#39;.debug, data.message.variable);</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        ipc.server.emit(</div>
<div class="line">            {</div>
<div class="line">                address : &#39;127.0.0.1&#39;, //any hostname will work</div>
<div class="line">                port    : ipc.config.networkPort</div>
<div class="line">            },</div>
<div class="line">            &#39;message&#39;,</div>
<div class="line">            {</div>
<div class="line">                from    : ipc.config.id,</div>
<div class="line">                message : &#39;Hello&#39;</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">ipc.server.start();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22557"></a>
Raw Buffer or Binary Sockets</h3>
<p>Binary or Buffer sockets can be used with any of the above socket types, however the way data events are emit is <em><b>slightly</b></em> different. These may come in handy if working with embedded systems or C / C++ processes. You can even make sure to match C or C++ string typing.</p>
<p>When setting up a rawBuffer socket you must specify it as such :</p>
<div class="fragment"><div class="line">ipc.config.rawBuffer=true;</div>
</div><!-- fragment --><p>You can also specify its encoding type. The default is <code>utf8</code></p>
<div class="fragment"><div class="line">ipc.config.encoding=&#39;utf8&#39;;</div>
</div><!-- fragment --><p>emit string buffer :</p>
<div class="fragment"><div class="line">//server</div>
<div class="line">ipc.server.emit(</div>
<div class="line">    socket,</div>
<div class="line">    &#39;hello&#39;</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">//client</div>
<div class="line">ipc.of.world.emit(</div>
<div class="line">    &#39;hello&#39;</div>
<div class="line">)</div>
</div><!-- fragment --><p>emit byte array buffer :</p>
<div class="fragment"><div class="line">//hex encoding may work best for this.</div>
<div class="line">ipc.config.encoding=&#39;hex&#39;;</div>
<div class="line"> </div>
<div class="line">//server</div>
<div class="line">ipc.server.emit(</div>
<div class="line">    socket,</div>
<div class="line">    [10,20,30]</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">//client</div>
<div class="line">ipc.server.emit(</div>
<div class="line">    [10,20,30]</div>
<div class="line">);</div>
</div><!-- fragment --><p>emit binary or hex array buffer, this is best for real time data transfer, especially whan connecting to C or C++ processes, or embedded systems :</p>
<div class="fragment"><div class="line">ipc.config.encoding=&#39;hex&#39;;</div>
<div class="line"> </div>
<div class="line">//server</div>
<div class="line">ipc.server.emit(</div>
<div class="line">    socket,</div>
<div class="line">    [0x05,0x6d,0x5c]</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">//client</div>
<div class="line">ipc.server.emit(</div>
<div class="line">    [0x05,0x6d,0x5c]</div>
<div class="line">);</div>
</div><!-- fragment --><p>Writing explicit buffers, int types, doubles, floats etc. as well as big endian and little endian data to raw buffer nostly valuable when connecting to C or C++ processes, or embedded systems (see more detailed info on buffers as well as UInt, Int, double etc. here)[<a href="https://nodejs.org/api/buffer.html">https://nodejs.org/api/buffer.html</a>]:</p>
<div class="fragment"><div class="line">ipc.config.encoding=&#39;hex&#39;;</div>
<div class="line"> </div>
<div class="line">//make a 6 byte buffer for example</div>
<div class="line">const myBuffer=Buffer.alloc(6).fill(0);</div>
<div class="line"> </div>
<div class="line">//fill the first 2 bytes with a 16 bit (2 byte) short unsigned int</div>
<div class="line"> </div>
<div class="line">//write a UInt16 (2 byte or short) as Big Endian</div>
<div class="line">myBuffer.writeUInt16BE(</div>
<div class="line">    2, //value to write</div>
<div class="line">    0 //offset in bytes</div>
<div class="line">);</div>
<div class="line">//OR</div>
<div class="line">myBuffer.writeUInt16LE(0x2,0);</div>
<div class="line">//OR</div>
<div class="line">myBuffer.writeUInt16LE(0x02,0);</div>
<div class="line"> </div>
<div class="line">//fill the remaining 4 bytes with a 32 bit (4 byte) long unsigned int</div>
<div class="line"> </div>
<div class="line">//write a UInt32 (4 byte or long) as Big Endian</div>
<div class="line">myBuffer.writeUInt32BE(</div>
<div class="line">    16772812, //value to write</div>
<div class="line">    2 //offset in bytes</div>
<div class="line">);</div>
<div class="line">//OR</div>
<div class="line">myBuffer.writeUInt32BE(0xffeecc,0)</div>
<div class="line"> </div>
<div class="line">//server</div>
<div class="line">ipc.server.emit(</div>
<div class="line">    socket,</div>
<div class="line">    myBuffer</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">//client</div>
<div class="line">ipc.server.emit(</div>
<div class="line">    myBuffer</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22558"></a>
Server with the &lt;tt&gt;cluster&lt;/tt&gt; Module</h3>
<p><code>node-ipc</code> can be used with Node.js' <a href="https://nodejs.org/api/cluster.html">cluster module</a> to provide the ability to have multiple readers for a single socket. Doing so simply requires you to set the <code>unlink</code> property in the config to <code>false</code> and take care of unlinking the socket path in the master process:</p>
<h4><a class="anchor" id="autotoc_md22559"></a>
Server</h4>
<div class="fragment"><div class="line">const fs = require(&#39;fs&#39;);</div>
<div class="line">const ipc=require(&#39;../../../node-ipc&#39;);</div>
<div class="line">const cpuCount = require(&#39;os&#39;).cpus().length;</div>
<div class="line">const cluster = require(&#39;cluster&#39;);</div>
<div class="line">const socketPath = &#39;/tmp/ipc.sock&#39;;</div>
<div class="line"> </div>
<div class="line">ipc.config.unlink = false;</div>
<div class="line"> </div>
<div class="line">if (cluster.isMaster) {</div>
<div class="line">   if (fs.existsSync(socketPath)) {</div>
<div class="line">       fs.unlinkSync(socketPath);</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   for (let i = 0; i &lt; cpuCount; i++) {</div>
<div class="line">       cluster.fork();</div>
<div class="line">   }</div>
<div class="line">}else{</div>
<div class="line">   ipc.serve(</div>
<div class="line">     socketPath,</div>
<div class="line">     function() {</div>
<div class="line">       ipc.server.on(</div>
<div class="line">         &#39;currentDate&#39;,</div>
<div class="line">         function(data,socket) {</div>
<div class="line">           console.log(`pid ${process.pid} got: `, data);</div>
<div class="line">         }</div>
<div class="line">       );</div>
<div class="line">     }</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  ipc.server.start();</div>
<div class="line">  console.log(`pid ${process.pid} listening on ${socketPath}`);</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md22560"></a>
Client</h4>
<div class="fragment"><div class="line">const fs = require(&#39;fs&#39;);</div>
<div class="line">const ipc = require(&#39;../../node-ipc&#39;);</div>
<div class="line"> </div>
<div class="line">const socketPath = &#39;/tmp/ipc.sock&#39;;</div>
<div class="line"> </div>
<div class="line">//loop forever so you can see the pid of the cluster sever change in the logs</div>
<div class="line">setInterval(</div>
<div class="line">  function() {</div>
<div class="line">    ipc.connectTo(</div>
<div class="line">      &#39;world&#39;,</div>
<div class="line">      socketPath,</div>
<div class="line">      connecting</div>
<div class="line">     );</div>
<div class="line">  },</div>
<div class="line">  2000</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">function connecting(socket) {</div>
<div class="line">  ipc.of.world.on(</div>
<div class="line">    &#39;connect&#39;,</div>
<div class="line">    function() {</div>
<div class="line">      ipc.of.world.emit(</div>
<div class="line">        &#39;currentDate&#39;,</div>
<div class="line">        {</div>
<div class="line">             message: new Date().toISOString()</div>
<div class="line">        }</div>
<div class="line">      );</div>
<div class="line">      ipc.disconnect(&#39;world&#39;);</div>
<div class="line">    }</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22561"></a>
Licensed under MIT license</h3>
<p>See the <a href="https://github.com/RIAEvangelist/node-ipc/blob/master/license">MIT license</a> file. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
