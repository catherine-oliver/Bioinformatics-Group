<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vaccine Dashboard: werkzeug.urls Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vaccine Dashboard
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacewerkzeug_1_1urls.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">werkzeug.urls Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwerkzeug_1_1urls_1_1___u_r_l_tuple.html">_URLTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwerkzeug_1_1urls_1_1_base_u_r_l.html">BaseURL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwerkzeug_1_1urls_1_1_u_r_l.html">URL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwerkzeug_1_1urls_1_1_bytes_u_r_l.html">BytesURL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwerkzeug_1_1urls_1_1_href.html">Href</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaf24a051aff29812612629f2bb533f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwerkzeug_1_1urls_1_1_base_u_r_l.html">BaseURL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#aaf24a051aff29812612629f2bb533f74">url_parse</a> (str url, t.Optional[str] scheme=None, bool allow_fragments=True)</td></tr>
<tr class="separator:aaf24a051aff29812612629f2bb533f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883d63c5dd8447aabe373e20b318ec86"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a883d63c5dd8447aabe373e20b318ec86">url_quote</a> (t.Union[str, bytes] string, str charset=&quot;utf-8&quot;, str errors=&quot;strict&quot;, t.Union[str, bytes] safe=&quot;/:&quot;, t.Union[str, bytes] unsafe=&quot;&quot;)</td></tr>
<tr class="separator:a883d63c5dd8447aabe373e20b318ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e10b28114fda425ed938434cb01aca0"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a6e10b28114fda425ed938434cb01aca0">url_quote_plus</a> (str string, str charset=&quot;utf-8&quot;, str errors=&quot;strict&quot;, str safe=&quot;&quot;)</td></tr>
<tr class="separator:a6e10b28114fda425ed938434cb01aca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faefa1a87386d77382ce764c57ed0ac"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a1faefa1a87386d77382ce764c57ed0ac">url_unparse</a> (t.Tuple[str, str, str, str, str] components)</td></tr>
<tr class="separator:a1faefa1a87386d77382ce764c57ed0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85edc3e19950c5468f338a7b4b6df15"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#af85edc3e19950c5468f338a7b4b6df15">url_unquote</a> (t.Union[str, bytes] s, str charset=&quot;utf-8&quot;, str errors=&quot;replace&quot;, str unsafe=&quot;&quot;)</td></tr>
<tr class="separator:af85edc3e19950c5468f338a7b4b6df15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858a3e4e69d3ff4d4f1b6565663d0204"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a858a3e4e69d3ff4d4f1b6565663d0204">url_unquote_plus</a> (t.Union[str, bytes] s, str charset=&quot;utf-8&quot;, str errors=&quot;replace&quot;)</td></tr>
<tr class="separator:a858a3e4e69d3ff4d4f1b6565663d0204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c6d43d7a5bb50f69c867521b23b67c"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a75c6d43d7a5bb50f69c867521b23b67c">url_fix</a> (str s, str charset=&quot;utf-8&quot;)</td></tr>
<tr class="separator:a75c6d43d7a5bb50f69c867521b23b67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ecd3ac0af829db37dd7999d3260453"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a16ecd3ac0af829db37dd7999d3260453">uri_to_iri</a> (t.Union[str, t.Tuple[str, str, str, str, str]] uri, str charset=&quot;utf-8&quot;, str errors=&quot;werkzeug.url_quote&quot;)</td></tr>
<tr class="separator:a16ecd3ac0af829db37dd7999d3260453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734dd14941c52352885bcc9e6bc3a165"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a734dd14941c52352885bcc9e6bc3a165">iri_to_uri</a> (t.Union[str, t.Tuple[str, str, str, str, str]] iri, str charset=&quot;utf-8&quot;, str errors=&quot;strict&quot;, bool safe_conversion=False)</td></tr>
<tr class="separator:a734dd14941c52352885bcc9e6bc3a165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab466506251fa365fd123086ee1666d2b"><td class="memItemLeft" align="right" valign="top">&quot;ds.MultiDict[str, str]&quot;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#ab466506251fa365fd123086ee1666d2b">url_decode</a> (t.AnyStr s, str charset=&quot;utf-8&quot;, None decode_keys=None, bool include_empty=True, str errors=&quot;replace&quot;, str separator=&quot;&amp;&quot;, t.Optional[t.Type[&quot;ds.MultiDict&quot;]] cls=None)</td></tr>
<tr class="separator:ab466506251fa365fd123086ee1666d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33306c41723fd1a8011be6def489a288"><td class="memItemLeft" align="right" valign="top">&quot;ds.MultiDict[str, str]&quot;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a33306c41723fd1a8011be6def489a288">url_decode_stream</a> (t.BinaryIO stream, str charset=&quot;utf-8&quot;, None decode_keys=None, bool include_empty=True, str errors=&quot;replace&quot;, bytes separator=b&quot;&amp;&quot;, t.Optional[t.Type[&quot;ds.MultiDict&quot;]] cls=None, t.Optional[int] limit=None, bool return_iterator=False)</td></tr>
<tr class="separator:a33306c41723fd1a8011be6def489a288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192758953bb07c565c2b02906df3944"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#a4192758953bb07c565c2b02906df3944">url_encode</a> (t.Union[t.Mapping[str, str], t.Iterable[t.Tuple[str, str]]] obj, str charset=&quot;utf-8&quot;, None encode_keys=None, bool sort=False, t.Optional[t.Callable[[t.Tuple[str, str]], t.Any]] key=None, str separator=&quot;&amp;&quot;)</td></tr>
<tr class="separator:a4192758953bb07c565c2b02906df3944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5ccaf81826ae8b79e1f47ca598cd"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#af5dc5ccaf81826ae8b79e1f47ca598cd">url_encode_stream</a> (t.Union[t.Mapping[str, str], t.Iterable[t.Tuple[str, str]]] obj, t.Optional[t.TextIO] stream=None, str charset=&quot;utf-8&quot;, None encode_keys=None, bool sort=False, t.Optional[t.Callable[[t.Tuple[str, str]], t.Any]] key=None, str separator=&quot;&amp;&quot;)</td></tr>
<tr class="separator:af5dc5ccaf81826ae8b79e1f47ca598cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44b21cdd36ed6ec58a73874bc08d0d9"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewerkzeug_1_1urls.html#ae44b21cdd36ed6ec58a73874bc08d0d9">url_join</a> (t.Union[str, t.Tuple[str, str, str, str, str]] base, t.Union[str, t.Tuple[str, str, str, str, str]] url, bool allow_fragments=True)</td></tr>
<tr class="separator:ae44b21cdd36ed6ec58a73874bc08d0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for working with URLs.

Contains implementations of functions from :mod:`urllib.parse` that
handle bytes and strings.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a734dd14941c52352885bcc9e6bc3a165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734dd14941c52352885bcc9e6bc3a165">&#9670;&nbsp;</a></span>iri_to_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.iri_to_uri </td>
          <td>(</td>
          <td class="paramtype">t.Union[str, t.Tuple[str, str, str, str, str]]&#160;</td>
          <td class="paramname"><em>iri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;strict&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>safe_conversion</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert an IRI to a URI. All non-ASCII and unsafe characters are
quoted. If the URL has a domain, it is encoded to Punycode.

&gt;&gt;&gt; iri_to_uri('http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF')
'http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF'

:param iri: The IRI to convert.
:param charset: The encoding of the IRI.
:param errors: Error handler to use during ``bytes.encode``.
:param safe_conversion: Return the URL unchanged if it only contains
    ASCII characters and no whitespace. See the explanation below.

There is a general problem with IRI conversion with some protocols
that are in violation of the URI specification. Consider the
following two IRIs::

    magnet:?xt=uri:whatever
    itms-services://?action=download-manifest

After parsing, we don't know if the scheme requires the ``//``,
which is dropped if empty, but conveys different meanings in the
final URL if it's present or not. In this case, you can use
``safe_conversion``, which will return the URL unchanged if it only
contains ASCII characters and no whitespace. This can result in a
URI with unquoted characters if it was not already quoted correctly,
but preserves the URL's semantics. Werkzeug uses this for the
``Location`` header for redirects.

.. versionchanged:: 0.15
    All reserved characters remain unquoted. Previously, only some
    reserved characters were left unquoted.

.. versionchanged:: 0.9.6
   The ``safe_conversion`` parameter was added.

.. versionadded:: 0.6
</pre> 
<p class="reference">References <a class="el" href="namespacewerkzeug_1_1urls.html#aaf24a051aff29812612629f2bb533f74">werkzeug.urls.url_parse()</a>, <a class="el" href="namespacewerkzeug_1_1urls.html#a883d63c5dd8447aabe373e20b318ec86">werkzeug.urls.url_quote()</a>, and <a class="el" href="namespacewerkzeug_1_1urls.html#a1faefa1a87386d77382ce764c57ed0ac">werkzeug.urls.url_unparse()</a>.</p>

</div>
</div>
<a id="a16ecd3ac0af829db37dd7999d3260453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ecd3ac0af829db37dd7999d3260453">&#9670;&nbsp;</a></span>uri_to_iri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.uri_to_iri </td>
          <td>(</td>
          <td class="paramtype">t.Union[str, t.Tuple[str, str, str, str, str]]&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;werkzeug.url_quote&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a URI to an IRI. All valid UTF-8 characters are unquoted,
leaving all reserved and invalid characters quoted. If the URL has
a domain, it is decoded from Punycode.

&gt;&gt;&gt; uri_to_iri("http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF")
'http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF'

:param uri: The URI to convert.
:param charset: The encoding to encode unquoted bytes with.
:param errors: Error handler to use during ``bytes.encode``. By
    default, invalid bytes are left quoted.

.. versionchanged:: 0.15
    All reserved and invalid characters remain quoted. Previously,
    only some reserved characters were preserved, and invalid bytes
    were replaced instead of left quoted.

.. versionadded:: 0.6
</pre> 
<p class="reference">References <a class="el" href="namespacewerkzeug_1_1urls.html#aaf24a051aff29812612629f2bb533f74">werkzeug.urls.url_parse()</a>, <a class="el" href="namespacewerkzeug_1_1urls.html#a1faefa1a87386d77382ce764c57ed0ac">werkzeug.urls.url_unparse()</a>, and <a class="el" href="namespacewerkzeug_1_1urls.html#af85edc3e19950c5468f338a7b4b6df15">werkzeug.urls.url_unquote()</a>.</p>

</div>
</div>
<a id="ab466506251fa365fd123086ee1666d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab466506251fa365fd123086ee1666d2b">&#9670;&nbsp;</a></span>url_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> &quot;ds.MultiDict[str, str]&quot; werkzeug.urls.url_decode </td>
          <td>(</td>
          <td class="paramtype">t.AnyStr&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>decode_keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>include_empty</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;replace&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&amp;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Optional[t.Type[&quot;ds.MultiDict&quot;]] &#160;</td>
          <td class="paramname"><em>cls</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse a query string and return it as a :class:`MultiDict`.

:param s: The query string to parse.
:param charset: Decode bytes to string with this charset. If not
    given, bytes are returned as-is.
:param include_empty: Include keys with empty values in the dict.
:param errors: Error handling behavior when decoding bytes.
:param separator: Separator character between pairs.
:param cls: Container to hold result instead of :class:`MultiDict`.

.. versionchanged:: 2.0
    The ``decode_keys`` parameter is deprecated and will be removed
    in Werkzeug 2.1.

.. versionchanged:: 0.5
    In previous versions ";" and "&amp;" could be used for url decoding.
    Now only "&amp;" is supported. If you want to use ";", a different
    ``separator`` can be provided.

.. versionchanged:: 0.5
    The ``cls`` parameter was added.
</pre> 
</div>
</div>
<a id="a33306c41723fd1a8011be6def489a288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33306c41723fd1a8011be6def489a288">&#9670;&nbsp;</a></span>url_decode_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> &quot;ds.MultiDict[str, str]&quot; werkzeug.urls.url_decode_stream </td>
          <td>(</td>
          <td class="paramtype">t.BinaryIO&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>decode_keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>include_empty</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;replace&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes &#160;</td>
          <td class="paramname"><em>separator</em> = <code>b&quot;&amp;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Optional[t.Type[&quot;ds.MultiDict&quot;]] &#160;</td>
          <td class="paramname"><em>cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Optional[int] &#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>return_iterator</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Works like :func:`url_decode` but decodes a stream.  The behavior
of stream and limit follows functions like
:func:`~werkzeug.wsgi.make_line_iter`.  The generator of pairs is
directly fed to the `cls` so you can consume the data while it's
parsed.

:param stream: a stream with the encoded querystring
:param charset: the charset of the query string.  If set to `None`
    no decoding will take place.
:param include_empty: Set to `False` if you don't want empty values to
                      appear in the dict.
:param errors: the decoding error behavior.
:param separator: the pair separator to be used, defaults to ``&amp;``
:param cls: an optional dict class to use.  If this is not specified
                   or `None` the default :class:`MultiDict` is used.
:param limit: the content length of the URL data.  Not necessary if
              a limited stream is provided.

.. versionchanged:: 2.0
    The ``decode_keys`` and ``return_iterator`` parameters are
    deprecated and will be removed in Werkzeug 2.1.

.. versionadded:: 0.8
</pre> 
<p class="reference">References <a class="el" href="namespacewerkzeug_1_1wsgi.html#a37b01c7a63483383211eeb14f58a5c58">werkzeug.wsgi.make_chunk_iter()</a>, <a class="el" href="namespaceattr.html#ab7304213fe02a4828528ee572122c00b">attr.s</a>, and <a class="el" href="namespacewerkzeug_1_1urls.html#a858a3e4e69d3ff4d4f1b6565663d0204">werkzeug.urls.url_unquote_plus()</a>.</p>

</div>
</div>
<a id="a4192758953bb07c565c2b02906df3944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4192758953bb07c565c2b02906df3944">&#9670;&nbsp;</a></span>url_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_encode </td>
          <td>(</td>
          <td class="paramtype">t.Union[t.Mapping[str, str], t.Iterable[t.Tuple[str, str]]]&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>encode_keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Optional[t.Callable[[t.Tuple[str, str]], t.Any]] &#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&amp;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">URL encode a dict/`MultiDict`.  If a value is `None` it will not appear
in the result string.  Per default only values are encoded into the target
charset strings.

:param obj: the object to encode into a query string.
:param charset: the charset of the query string.
:param sort: set to `True` if you want parameters to be sorted by `key`.
:param separator: the separator to be used for the pairs.
:param key: an optional function to be used for sorting.  For more details
            check out the :func:`sorted` documentation.

.. versionchanged:: 2.0
    The ``encode_keys`` parameter is deprecated and will be removed
    in Werkzeug 2.1.

.. versionchanged:: 0.5
    Added the ``sort``, ``key``, and ``separator`` parameters.
</pre> 
</div>
</div>
<a id="af5dc5ccaf81826ae8b79e1f47ca598cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5ccaf81826ae8b79e1f47ca598cd">&#9670;&nbsp;</a></span>url_encode_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None werkzeug.urls.url_encode_stream </td>
          <td>(</td>
          <td class="paramtype">t.Union[t.Mapping[str, str], t.Iterable[t.Tuple[str, str]]]&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Optional[t.TextIO] &#160;</td>
          <td class="paramname"><em>stream</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>encode_keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Optional[t.Callable[[t.Tuple[str, str]], t.Any]] &#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&amp;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like :meth:`url_encode` but writes the results to a stream
object.  If the stream is `None` a generator over all encoded
pairs is returned.

:param obj: the object to encode into a query string.
:param stream: a stream to write the encoded object into or `None` if
               an iterator over the encoded pairs should be returned.  In
               that case the separator argument is ignored.
:param charset: the charset of the query string.
:param sort: set to `True` if you want parameters to be sorted by `key`.
:param separator: the separator to be used for the pairs.
:param key: an optional function to be used for sorting.  For more details
            check out the :func:`sorted` documentation.

.. versionchanged:: 2.0
    The ``encode_keys`` parameter is deprecated and will be removed
    in Werkzeug 2.1.

.. versionadded:: 0.8
</pre> 
<p class="reference">References <a class="el" href="namespacepy_1_1__builtin.html#a738935bd44666db26cf67ff3f8c6b164">py._builtin.enumerate</a>.</p>

</div>
</div>
<a id="a75c6d43d7a5bb50f69c867521b23b67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c6d43d7a5bb50f69c867521b23b67c">&#9670;&nbsp;</a></span>url_fix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_fix </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sometimes you get an URL by a user that just isn't a real URL because
it contains unsafe characters like ' ' and so on. This function can fix
some of the problems in a similar way browsers handle data entered by the
user:

&gt;&gt;&gt; url_fix('http://de.wikipedia.org/wiki/Elf (Begriffskl\xe4rung)')
'http://de.wikipedia.org/wiki/Elf%20(Begriffskl%C3%A4rung)'

:param s: the string with the URL to fix.
:param charset: The target charset for the URL if the url was given
    as a string.
</pre> 
<p class="reference">References <a class="el" href="namespacepip_1_1__vendor_1_1pyparsing.html#ac84229f28b3ef0c25c51348445c99607">pip._vendor.pyparsing.range</a>, <a class="el" href="namespacepip_1_1__internal_1_1utils_1_1filesystem.html#a2fc3733bb724a9f843d542afc5a19055">pip._internal.utils.filesystem.replace</a>, <a class="el" href="namespacewerkzeug_1_1urls.html#aaf24a051aff29812612629f2bb533f74">werkzeug.urls.url_parse()</a>, <a class="el" href="namespacewerkzeug_1_1urls.html#a883d63c5dd8447aabe373e20b318ec86">werkzeug.urls.url_quote()</a>, <a class="el" href="namespacewerkzeug_1_1urls.html#a6e10b28114fda425ed938434cb01aca0">werkzeug.urls.url_quote_plus()</a>, and <a class="el" href="namespacewerkzeug_1_1urls.html#a1faefa1a87386d77382ce764c57ed0ac">werkzeug.urls.url_unparse()</a>.</p>

</div>
</div>
<a id="ae44b21cdd36ed6ec58a73874bc08d0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44b21cdd36ed6ec58a73874bc08d0d9">&#9670;&nbsp;</a></span>url_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_join </td>
          <td>(</td>
          <td class="paramtype">t.Union[str, t.Tuple[str, str, str, str, str]]&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Union[str, t.Tuple[str, str, str, str, str]]&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>allow_fragments</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Join a base URL and a possibly relative URL to form an absolute
interpretation of the latter.

:param base: the base URL for the join operation.
:param url: the URL to join.
:param allow_fragments: indicates whether fragments should be allowed.
</pre> 
<p class="reference">References <a class="el" href="namespaceattr.html#ab7304213fe02a4828528ee572122c00b">attr.s</a>, <a class="el" href="namespacewerkzeug_1_1urls.html#aaf24a051aff29812612629f2bb533f74">werkzeug.urls.url_parse()</a>, and <a class="el" href="namespacewerkzeug_1_1urls.html#a1faefa1a87386d77382ce764c57ed0ac">werkzeug.urls.url_unparse()</a>.</p>

</div>
</div>
<a id="aaf24a051aff29812612629f2bb533f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf24a051aff29812612629f2bb533f74">&#9670;&nbsp;</a></span>url_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwerkzeug_1_1urls_1_1_base_u_r_l.html">BaseURL</a> werkzeug.urls.url_parse </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Optional[str] &#160;</td>
          <td class="paramname"><em>scheme</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>allow_fragments</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parses a URL from a string into a :class:`URL` tuple.  If the URL
is lacking a scheme it can be provided as second argument. Otherwise,
it is ignored.  Optionally fragments can be stripped from the URL
by setting `allow_fragments` to `False`.

The inverse of this function is :func:`url_unparse`.

:param url: the URL to parse.
:param scheme: the default schema to use if the URL is schemaless.
:param allow_fragments: if set to `False` a fragment will be removed
                        from the URL.
</pre> 
<p class="reference">References <a class="el" href="namespacepy_1_1__builtin.html#a2c6699e227d28c411f49d5d6f8e260ce">py._builtin.any</a>, <a class="el" href="namespacepy_1_1__builtin.html#abaee473d3ac8229db31e234fe0ff82dc">py._builtin.frozenset</a>, <a class="el" href="namespacepip_1_1__vendor_1_1distlib_1_1compat.html#adf4817930ecc4f1170d9417fea7a0888">pip._vendor.distlib.compat.quote()</a>, <a class="el" href="namespacepip_1_1__vendor_1_1pyparsing.html#ac84229f28b3ef0c25c51348445c99607">pip._vendor.pyparsing.range</a>, <a class="el" href="namespacepip_1_1__internal_1_1utils_1_1filesystem.html#a2fc3733bb724a9f843d542afc5a19055">pip._internal.utils.filesystem.replace</a>, and <a class="el" href="namespaceattr.html#ab7304213fe02a4828528ee572122c00b">attr.s</a>.</p>

</div>
</div>
<a id="a883d63c5dd8447aabe373e20b318ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883d63c5dd8447aabe373e20b318ec86">&#9670;&nbsp;</a></span>url_quote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_quote </td>
          <td>(</td>
          <td class="paramtype">t.Union[str, bytes]&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;strict&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Union[str, bytes] &#160;</td>
          <td class="paramname"><em>safe</em> = <code>&quot;/:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t.Union[str, bytes] &#160;</td>
          <td class="paramname"><em>unsafe</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">URL encode a single string with a given encoding.

:param s: the string to quote.
:param charset: the charset to be used.
:param safe: an optional sequence of safe characters.
:param unsafe: an optional sequence of unsafe characters.

.. versionadded:: 0.9.2
   The `unsafe` parameter was added.
</pre> 
<p class="reference">References <a class="el" href="namespacepip_1_1__vendor_1_1requests_1_1compat.html#acdad6163620499e5156d111c77f6b709">pip._vendor.requests.compat.bytes</a>, <a class="el" href="namespacejwt_1_1api__jws.html#a4e689878c0294ef5105ff80ae99fe8f1">jwt.api_jws.decode</a>, <a class="el" href="namespacepy_1_1__builtin.html#abaee473d3ac8229db31e234fe0ff82dc">py._builtin.frozenset</a>, and <a class="el" href="namespacepip_1_1__vendor_1_1requests_1_1compat.html#a0a3891b273b8f1ce270e9356700eb984">pip._vendor.requests.compat.str</a>.</p>

</div>
</div>
<a id="a6e10b28114fda425ed938434cb01aca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e10b28114fda425ed938434cb01aca0">&#9670;&nbsp;</a></span>url_quote_plus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_quote_plus </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;strict&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>safe</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">URL encode a single string with the given encoding and convert
whitespace to "+".

:param s: The string to quote.
:param charset: The charset to be used.
:param safe: An optional sequence of safe characters.
</pre> 
<p class="reference">References <a class="el" href="namespacepip_1_1__internal_1_1utils_1_1filesystem.html#a2fc3733bb724a9f843d542afc5a19055">pip._internal.utils.filesystem.replace</a>, and <a class="el" href="namespacewerkzeug_1_1urls.html#a883d63c5dd8447aabe373e20b318ec86">werkzeug.urls.url_quote()</a>.</p>

</div>
</div>
<a id="a1faefa1a87386d77382ce764c57ed0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faefa1a87386d77382ce764c57ed0ac">&#9670;&nbsp;</a></span>url_unparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_unparse </td>
          <td>(</td>
          <td class="paramtype">t.Tuple[str, str, str, str, str]&#160;</td>
          <td class="paramname"><em>components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The reverse operation to :meth:`url_parse`.  This accepts arbitrary
as well as :class:`URL` tuples and returns a URL as a string.

:param components: the parsed URL as tuple which should be converted
                   into a URL string.
</pre> 
<p class="reference">References <a class="el" href="namespaceattr.html#ab7304213fe02a4828528ee572122c00b">attr.s</a>.</p>

</div>
</div>
<a id="af85edc3e19950c5468f338a7b4b6df15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85edc3e19950c5468f338a7b4b6df15">&#9670;&nbsp;</a></span>url_unquote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_unquote </td>
          <td>(</td>
          <td class="paramtype">t.Union[str, bytes]&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;replace&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>unsafe</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">URL decode a single string with a given encoding.  If the charset
is set to `None` no decoding is performed and raw bytes are
returned.

:param s: the string to unquote.
:param charset: the charset of the query string.  If set to `None`
    no decoding will take place.
:param errors: the error handling for the charset decoding.
</pre> 
</div>
</div>
<a id="a858a3e4e69d3ff4d4f1b6565663d0204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858a3e4e69d3ff4d4f1b6565663d0204">&#9670;&nbsp;</a></span>url_unquote_plus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str werkzeug.urls.url_unquote_plus </td>
          <td>(</td>
          <td class="paramtype">t.Union[str, bytes]&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>charset</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;replace&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">URL decode a single string with the given `charset` and decode "+" to
whitespace.

Per default encoding errors are ignored.  If you want a different behavior
you can set `errors` to ``'replace'`` or ``'strict'``.

:param s: The string to unquote.
:param charset: the charset of the query string.  If set to `None`
    no decoding will take place.
:param errors: The error handling for the `charset` decoding.
</pre> 
<p class="reference">References <a class="el" href="namespacewerkzeug_1_1urls.html#af85edc3e19950c5468f338a7b4b6df15">werkzeug.urls.url_unquote()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewerkzeug.html">werkzeug</a></li><li class="navelem"><a class="el" href="namespacewerkzeug_1_1urls.html">urls</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
