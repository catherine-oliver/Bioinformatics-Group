<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vaccine Dashboard: attr._make Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vaccine Dashboard
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceattr_1_1__make.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">attr._make Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classattr_1_1__make_1_1___nothing.html">_Nothing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classattr_1_1__make_1_1___cache_hash_wrapper.html">_CacheHashWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classattr_1_1__make_1_1___class_builder.html">_ClassBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classattr_1_1__make_1_1_attribute.html">Attribute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classattr_1_1__make_1_1___counting_attr.html">_CountingAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classattr_1_1__make_1_1_factory.html">Factory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classattr_1_1__make_1_1___and_validator.html">_AndValidator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29239e597ba1943576e22e54ff8c0fba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a29239e597ba1943576e22e54ff8c0fba">attrib</a> (default=<a class="el" href="namespaceattr_1_1__make.html#a4b0e597eb2f1bb453e7502bf9e1ec615">NOTHING</a>, validator=None, repr=True, cmp=None, hash=None, init=True, metadata=None, type=None, converter=None, factory=None, kw_only=False, eq=None, order=None, on_setattr=None)</td></tr>
<tr class="separator:a29239e597ba1943576e22e54ff8c0fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47921ac2541011ff8b3acf81c85fd8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a> (maybe_cls=None, these=None, repr_ns=None, repr=None, cmp=None, hash=None, init=None, slots=False, frozen=False, weakref_slot=True, str=False, auto_attribs=False, kw_only=False, cache_hash=False, auto_exc=False, eq=None, order=None, auto_detect=False, collect_by_mro=False, getstate_setstate=None, on_setattr=None, field_transformer=None)</td></tr>
<tr class="separator:ac47921ac2541011ff8b3acf81c85fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357e306d8a24fb39dbeebe59d704d352"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a357e306d8a24fb39dbeebe59d704d352">fields</a> (cls)</td></tr>
<tr class="separator:a357e306d8a24fb39dbeebe59d704d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaa5f8707fabad43bfc9c4e13d06198"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a5aaa5f8707fabad43bfc9c4e13d06198">fields_dict</a> (cls)</td></tr>
<tr class="separator:a5aaa5f8707fabad43bfc9c4e13d06198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0977efca96d32ec875de623eb6887c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#ae0977efca96d32ec875de623eb6887c3">validate</a> (inst)</td></tr>
<tr class="separator:ae0977efca96d32ec875de623eb6887c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97611bdf2dd52ad5d504c4a08c6c9add"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a97611bdf2dd52ad5d504c4a08c6c9add">make_class</a> (name, <a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a>, bases=(object,), **attributes_arguments)</td></tr>
<tr class="separator:a97611bdf2dd52ad5d504c4a08c6c9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102e818fc4028edff9f21da6ad826bea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a102e818fc4028edff9f21da6ad826bea">and_</a> (*validators)</td></tr>
<tr class="separator:a102e818fc4028edff9f21da6ad826bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ef7b8b1b1f5d7ddbd625c3b7d2ada9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a82ef7b8b1b1f5d7ddbd625c3b7d2ada9">pipe</a> (*converters)</td></tr>
<tr class="separator:a82ef7b8b1b1f5d7ddbd625c3b7d2ada9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4b0e597eb2f1bb453e7502bf9e1ec615"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a4b0e597eb2f1bb453e7502bf9e1ec615">NOTHING</a> = <a class="el" href="classattr_1_1__make_1_1___nothing.html">_Nothing</a>()</td></tr>
<tr class="separator:a4b0e597eb2f1bb453e7502bf9e1ec615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac510a4d2982a3b5968875d946197801c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#ac510a4d2982a3b5968875d946197801c">Attribute</a></td></tr>
<tr class="separator:ac510a4d2982a3b5968875d946197801c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3558f3744fa4ca31912898ce1a759969"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__make.html#a3558f3744fa4ca31912898ce1a759969">Factory</a> = _add_hash(_add_eq(_add_repr(<a class="el" href="classattr_1_1__make_1_1_factory.html">Factory</a>, <a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a>=_f), <a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a>=_f), <a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a>=_f)</td></tr>
<tr class="separator:a3558f3744fa4ca31912898ce1a759969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a102e818fc4028edff9f21da6ad826bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102e818fc4028edff9f21da6ad826bea">&#9670;&nbsp;</a></span>and_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.and_ </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>validators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A validator that composes multiple validators into one.

When called on a value, it runs all wrapped validators.

:param callables validators: Arbitrary number of validators.

.. versionadded:: 17.1.0
</pre> 
</div>
</div>
<a id="a29239e597ba1943576e22e54ff8c0fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29239e597ba1943576e22e54ff8c0fba">&#9670;&nbsp;</a></span>attrib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.attrib </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="namespaceattr_1_1__make.html#a4b0e597eb2f1bb453e7502bf9e1ec615">NOTHING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>validator</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repr</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hash</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>converter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>on_setattr</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new attribute on a class.

..  warning::

    Does *not* do anything unless the class is also decorated with
    `attr.s`!

:param default: A value that is used if an ``attrs``-generated ``__init__``
    is used and no value is passed while instantiating or the attribute is
    excluded using ``init=False``.

    If the value is an instance of `Factory`, its callable will be
    used to construct a new value (useful for mutable data types like lists
    or dicts).

    If a default is not set (or set manually to `attr.NOTHING`), a value
    *must* be supplied when instantiating; otherwise a `TypeError`
    will be raised.

    The default can also be set using decorator notation as shown below.

:type default: Any value

:param callable factory: Syntactic sugar for
    ``default=attr.Factory(factory)``.

:param validator: `callable` that is called by ``attrs``-generated
    ``__init__`` methods after the instance has been initialized.  They
    receive the initialized instance, the `Attribute`, and the
    passed value.

    The return value is *not* inspected so the validator has to throw an
    exception itself.

    If a `list` is passed, its items are treated as validators and must
    all pass.

    Validators can be globally disabled and re-enabled using
    `get_run_validators`.

    The validator can also be set using decorator notation as shown below.

:type validator: `callable` or a `list` of `callable`\\ s.

:param repr: Include this attribute in the generated ``__repr__``
    method. If ``True``, include the attribute; if ``False``, omit it. By
    default, the built-in ``repr()`` function is used. To override how the
    attribute value is formatted, pass a ``callable`` that takes a single
    value and returns a string. Note that the resulting string is used
    as-is, i.e. it will be used directly *instead* of calling ``repr()``
    (the default).
:type repr: a `bool` or a `callable` to use a custom function.

:param eq: If ``True`` (default), include this attribute in the
    generated ``__eq__`` and ``__ne__`` methods that check two instances
    for equality. To override how the attribute value is compared,
    pass a ``callable`` that takes a single value and returns the value
    to be compared.
:type eq: a `bool` or a `callable`.

:param order: If ``True`` (default), include this attributes in the
    generated ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods.
    To override how the attribute value is ordered,
    pass a ``callable`` that takes a single value and returns the value
    to be ordered.
:type order: a `bool` or a `callable`.

:param cmp: Setting *cmp* is equivalent to setting *eq* and *order* to the
    same value. Must not be mixed with *eq* or *order*.
:type cmp: a `bool` or a `callable`.

:param Optional[bool] hash: Include this attribute in the generated
    ``__hash__`` method.  If ``None`` (default), mirror *eq*'s value.  This
    is the correct behavior according the Python spec.  Setting this value
    to anything else than ``None`` is *discouraged*.
:param bool init: Include this attribute in the generated ``__init__``
    method.  It is possible to set this to ``False`` and set a default
    value.  In that case this attributed is unconditionally initialized
    with the specified default value or factory.
:param callable converter: `callable` that is called by
    ``attrs``-generated ``__init__`` methods to convert attribute's value
    to the desired format.  It is given the passed-in value, and the
    returned value will be used as the new value of the attribute.  The
    value is converted before being passed to the validator, if any.
:param metadata: An arbitrary mapping, to be used by third-party
    components.  See `extending_metadata`.
:param type: The type of the attribute.  In Python 3.6 or greater, the
    preferred method to specify the type is using a variable annotation
    (see `PEP 526 &lt;https://www.python.org/dev/peps/pep-0526/&gt;`_).
    This argument is provided for backward compatibility.
    Regardless of the approach used, the type will be stored on
    ``Attribute.type``.

    Please note that ``attrs`` doesn't do anything with this metadata by
    itself. You can use it as part of your own code or for
    `static type checking &lt;types&gt;`.
:param kw_only: Make this attribute keyword-only (Python 3+)
    in the generated ``__init__`` (if ``init`` is ``False``, this
    parameter is ignored).
:param on_setattr: Allows to overwrite the *on_setattr* setting from
    `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.
    Set to `attr.setters.NO_OP` to run **no** `setattr` hooks for this
    attribute -- regardless of the setting in `attr.s`.
:type on_setattr: `callable`, or a list of callables, or `None`, or
    `attr.setters.NO_OP`

.. versionadded:: 15.2.0 *convert*
.. versionadded:: 16.3.0 *metadata*
.. versionchanged:: 17.1.0 *validator* can be a ``list`` now.
.. versionchanged:: 17.1.0
   *hash* is ``None`` and therefore mirrors *eq* by default.
.. versionadded:: 17.3.0 *type*
.. deprecated:: 17.4.0 *convert*
.. versionadded:: 17.4.0 *converter* as a replacement for the deprecated
   *convert* to achieve consistency with other noun-based arguments.
.. versionadded:: 18.1.0
   ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.
.. versionadded:: 18.2.0 *kw_only*
.. versionchanged:: 19.2.0 *convert* keyword argument removed.
.. versionchanged:: 19.2.0 *repr* also accepts a custom callable.
.. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.
.. versionadded:: 19.2.0 *eq* and *order*
.. versionadded:: 20.1.0 *on_setattr*
.. versionchanged:: 20.3.0 *kw_only* backported to Python 2
.. versionchanged:: 21.1.0
   *eq*, *order*, and *cmp* also accept a custom callable
.. versionchanged:: 21.1.0 *cmp* undeprecated
</pre> 
<p class="reference">References <a class="el" href="namespaceattr_1_1__make.html#a102e818fc4028edff9f21da6ad826bea">attr._make.and_()</a>, <a class="el" href="namespacecffi_1_1api.html#ac56d433f8b99b5336933cd23dbd18e06">cffi.api.callable</a>, <a class="el" href="namespacecffi_1_1ffiplatform.html#ab0cef98c8737ed95edf16b2b3b3e4fe5">cffi.ffiplatform.compile()</a>, <a class="el" href="namespacepy_1_1__builtin.html#a738935bd44666db26cf67ff3f8c6b164">py._builtin.enumerate</a>, <a class="el" href="namespacepip_1_1__vendor_1_1chardet_1_1compat.html#a4d983b61a6143123256a8c8eac84dd85">pip._vendor.chardet.compat.iteritems</a>, <a class="el" href="namespaceattr_1_1__make.html#a82ef7b8b1b1f5d7ddbd625c3b7d2ada9">attr._make.pipe()</a>, <a class="el" href="namespacepy_1_1__builtin.html#a75ae83d46de2fca162578dc7d357a921">py._builtin.reversed</a>, <a class="el" href="namespacepy_1_1__builtin.html#a2b2dc1c23346592e3b7dd26be6125f6c">py._builtin.set</a>, <a class="el" href="namespacepy_1_1__builtin.html#a177c70aafc7f8588fbb0ac6b0f2fe2c8">py._builtin.sorted</a>, and <a class="el" href="namespacepip_1_1__vendor_1_1requests_1_1compat.html#a0a3891b273b8f1ce270e9356700eb984">pip._vendor.requests.compat.str</a>.</p>

</div>
</div>
<a id="ac47921ac2541011ff8b3acf81c85fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47921ac2541011ff8b3acf81c85fd8f">&#9670;&nbsp;</a></span>attrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.attrs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maybe_cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>these</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repr_ns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hash</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slots</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frozen</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weakref_slot</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>str</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auto_attribs</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cache_hash</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auto_exc</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auto_detect</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>collect_by_mro</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>getstate_setstate</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>on_setattr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>field_transformer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A class decorator that adds `dunder
&lt;https://wiki.python.org/moin/DunderAlias&gt;`_\ -methods according to the
specified attributes using `attr.ib` or the *these* argument.

:param these: A dictionary of name to `attr.ib` mappings.  This is
    useful to avoid the definition of your attributes within the class body
    because you can't (e.g. if you want to add ``__repr__`` methods to
    Django models) or don't want to.

    If *these* is not ``None``, ``attrs`` will *not* search the class body
    for attributes and will *not* remove any attributes from it.

    If *these* is an ordered dict (`dict` on Python 3.6+,
    `collections.OrderedDict` otherwise), the order is deduced from
    the order of the attributes inside *these*.  Otherwise the order
    of the definition of the attributes is used.

:type these: `dict` of `str` to `attr.ib`

:param str repr_ns: When using nested classes, there's no way in Python 2
    to automatically detect that.  Therefore it's possible to set the
    namespace explicitly for a more meaningful ``repr`` output.
:param bool auto_detect: Instead of setting the *init*, *repr*, *eq*,
    *order*, and *hash* arguments explicitly, assume they are set to
    ``True`` **unless any** of the involved methods for one of the
    arguments is implemented in the *current* class (i.e. it is *not*
    inherited from some base class).

    So for example by implementing ``__eq__`` on a class yourself,
    ``attrs`` will deduce ``eq=False`` and will create *neither*
    ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible
    ``__ne__`` by default, so it *should* be enough to only implement
    ``__eq__`` in most cases).

    .. warning::

       If you prevent ``attrs`` from creating the ordering methods for you
       (``order=False``, e.g. by implementing ``__le__``), it becomes
       *your* responsibility to make sure its ordering is sound. The best
       way is to use the `functools.total_ordering` decorator.


    Passing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,
    *cmp*, or *hash* overrides whatever *auto_detect* would determine.

    *auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises
    a `PythonTooOldError`.

:param bool repr: Create a ``__repr__`` method with a human readable
    representation of ``attrs`` attributes..
:param bool str: Create a ``__str__`` method that is identical to
    ``__repr__``.  This is usually not necessary except for
    `Exception`\ s.
:param Optional[bool] eq: If ``True`` or ``None`` (default), add ``__eq__``
    and ``__ne__`` methods that check two instances for equality.

    They compare the instances as if they were tuples of their ``attrs``
    attributes if and only if the types of both classes are *identical*!
:param Optional[bool] order: If ``True``, add ``__lt__``, ``__le__``,
    ``__gt__``, and ``__ge__`` methods that behave like *eq* above and
    allow instances to be ordered. If ``None`` (default) mirror value of
    *eq*.
:param Optional[bool] cmp: Setting *cmp* is equivalent to setting *eq*
    and *order* to the same value. Must not be mixed with *eq* or *order*.
:param Optional[bool] hash: If ``None`` (default), the ``__hash__`` method
    is generated according how *eq* and *frozen* are set.

    1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.
    2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to
       None, marking it unhashable (which it is).
    3. If *eq* is False, ``__hash__`` will be left untouched meaning the
       ``__hash__`` method of the base class will be used (if base class is
       ``object``, this means it will fall back to id-based hashing.).

    Although not recommended, you can decide for yourself and force
    ``attrs`` to create one (e.g. if the class is immutable even though you
    didn't freeze it programmatically) by passing ``True`` or not.  Both of
    these cases are rather special and should be used carefully.

    See our documentation on `hashing`, Python's documentation on
    `object.__hash__`, and the `GitHub issue that led to the default \
    behavior &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more
    details.
:param bool init: Create a ``__init__`` method that initializes the
    ``attrs`` attributes. Leading underscores are stripped for the argument
    name. If a ``__attrs_pre_init__`` method exists on the class, it will
    be called before the class is initialized. If a ``__attrs_post_init__``
    method exists on the class, it will be called after the class is fully
    initialized.

    If ``init`` is ``False``, an ``__attrs_init__`` method will be
    injected instead. This allows you to define a custom ``__init__``
    method that can do pre-init work such as ``super().__init__()``,
    and then call ``__attrs_init__()`` and ``__attrs_post_init__()``.
:param bool slots: Create a `slotted class &lt;slotted classes&gt;` that's more
    memory-efficient. Slotted classes are generally superior to the default
    dict classes, but have some gotchas you should know about, so we
    encourage you to read the `glossary entry &lt;slotted classes&gt;`.
:param bool frozen: Make instances immutable after initialization.  If
    someone attempts to modify a frozen instance,
    `attr.exceptions.FrozenInstanceError` is raised.

    .. note::

        1. This is achieved by installing a custom ``__setattr__`` method
           on your class, so you can't implement your own.

        2. True immutability is impossible in Python.

        3. This *does* have a minor a runtime performance `impact
           &lt;how-frozen&gt;` when initializing new instances.  In other words:
           ``__init__`` is slightly slower with ``frozen=True``.

        4. If a class is frozen, you cannot modify ``self`` in
           ``__attrs_post_init__`` or a self-written ``__init__``. You can
           circumvent that limitation by using
           ``object.__setattr__(self, "attribute_name", value)``.

        5. Subclasses of a frozen class are frozen too.

:param bool weakref_slot: Make instances weak-referenceable.  This has no
    effect unless ``slots`` is also enabled.
:param bool auto_attribs: If ``True``, collect `PEP 526`_-annotated
    attributes (Python 3.6 and later only) from the class body.

    In this case, you **must** annotate every field.  If ``attrs``
    encounters a field that is set to an `attr.ib` but lacks a type
    annotation, an `attr.exceptions.UnannotatedAttributeError` is
    raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't
    want to set a type.

    If you assign a value to those attributes (e.g. ``x: int = 42``), that
    value becomes the default value like if it were passed using
    ``attr.ib(default=42)``.  Passing an instance of `Factory` also
    works as expected in most cases (see warning below).

    Attributes annotated as `typing.ClassVar`, and attributes that are
    neither annotated nor set to an `attr.ib` are **ignored**.

    .. warning::
       For features that use the attribute name to create decorators (e.g.
       `validators &lt;validators&gt;`), you still *must* assign `attr.ib` to
       them. Otherwise Python will either not find the name or try to use
       the default value to call e.g. ``validator`` on it.

       These errors can be quite confusing and probably the most common bug
       report on our bug tracker.

    .. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/
:param bool kw_only: Make all attributes keyword-only (Python 3+)
    in the generated ``__init__`` (if ``init`` is ``False``, this
    parameter is ignored).
:param bool cache_hash: Ensure that the object's hash code is computed
    only once and stored on the object.  If this is set to ``True``,
    hashing must be either explicitly or implicitly enabled for this
    class.  If the hash code is cached, avoid any reassignments of
    fields involved in hash code computation or mutations of the objects
    those fields point to after object creation.  If such changes occur,
    the behavior of the object's hash code is undefined.
:param bool auto_exc: If the class subclasses `BaseException`
    (which implicitly includes any subclass of any exception), the
    following happens to behave like a well-behaved Python exceptions
    class:

    - the values for *eq*, *order*, and *hash* are ignored and the
      instances compare and hash by the instance's ids (N.B. ``attrs`` will
      *not* remove existing implementations of ``__hash__`` or the equality
      methods. It just won't add own ones.),
    - all attributes that are either passed into ``__init__`` or have a
      default value are additionally available as a tuple in the ``args``
      attribute,
    - the value of *str* is ignored leaving ``__str__`` to base classes.
:param bool collect_by_mro: Setting this to `True` fixes the way ``attrs``
   collects attributes from base classes.  The default behavior is
   incorrect in certain cases of multiple inheritance.  It should be on by
   default but is kept off for backward-compatability.

   See issue `#428 &lt;https://github.com/python-attrs/attrs/issues/428&gt;`_ for
   more details.

:param Optional[bool] getstate_setstate:
   .. note::
      This is usually only interesting for slotted classes and you should
      probably just set *auto_detect* to `True`.

   If `True`, ``__getstate__`` and
   ``__setstate__`` are generated and attached to the class. This is
   necessary for slotted classes to be pickleable. If left `None`, it's
   `True` by default for slotted classes and ``False`` for dict classes.

   If *auto_detect* is `True`, and *getstate_setstate* is left `None`,
   and **either** ``__getstate__`` or ``__setstate__`` is detected directly
   on the class (i.e. not inherited), it is set to `False` (this is usually
   what you want).

:param on_setattr: A callable that is run whenever the user attempts to set
    an attribute (either by assignment like ``i.x = 42`` or by using
    `setattr` like ``setattr(i, "x", 42)``). It receives the same arguments
    as validators: the instance, the attribute that is being modified, and
    the new value.

    If no exception is raised, the attribute is set to the return value of
    the callable.

    If a list of callables is passed, they're automatically wrapped in an
    `attr.setters.pipe`.

:param Optional[callable] field_transformer:
    A function that is called with the original class object and all
    fields right before ``attrs`` finalizes the class.  You can use
    this, e.g., to automatically add converters or validators to
    fields based on their types.  See `transform-fields` for more details.

.. versionadded:: 16.0.0 *slots*
.. versionadded:: 16.1.0 *frozen*
.. versionadded:: 16.3.0 *str*
.. versionadded:: 16.3.0 Support for ``__attrs_post_init__``.
.. versionchanged:: 17.1.0
   *hash* supports ``None`` as value which is also the default now.
.. versionadded:: 17.3.0 *auto_attribs*
.. versionchanged:: 18.1.0
   If *these* is passed, no attributes are deleted from the class body.
.. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.
.. versionadded:: 18.2.0 *weakref_slot*
.. deprecated:: 18.2.0
   ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a
   `DeprecationWarning` if the classes compared are subclasses of
   each other. ``__eq`` and ``__ne__`` never tried to compared subclasses
   to each other.
.. versionchanged:: 19.2.0
   ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider
   subclasses comparable anymore.
.. versionadded:: 18.2.0 *kw_only*
.. versionadded:: 18.2.0 *cache_hash*
.. versionadded:: 19.1.0 *auto_exc*
.. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.
.. versionadded:: 19.2.0 *eq* and *order*
.. versionadded:: 20.1.0 *auto_detect*
.. versionadded:: 20.1.0 *collect_by_mro*
.. versionadded:: 20.1.0 *getstate_setstate*
.. versionadded:: 20.1.0 *on_setattr*
.. versionadded:: 20.3.0 *field_transformer*
.. versionchanged:: 21.1.0
   ``init=False`` injects ``__attrs_init__``
.. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__``
.. versionchanged:: 21.1.0 *cmp* undeprecated
</pre> 
<p class="reference">References <a class="el" href="namespacepip_1_1__vendor_1_1distro.html#a9a240f009c8550ce7857b788d952c653">pip._vendor.distro.id()</a>, <a class="el" href="namespacepy_1_1__builtin.html#a2b2dc1c23346592e3b7dd26be6125f6c">py._builtin.set</a>, and <a class="el" href="namespacepip_1_1__vendor_1_1requests_1_1compat.html#a0a3891b273b8f1ce270e9356700eb984">pip._vendor.requests.compat.str</a>.</p>

</div>
</div>
<a id="a357e306d8a24fb39dbeebe59d704d352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357e306d8a24fb39dbeebe59d704d352">&#9670;&nbsp;</a></span>fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the tuple of ``attrs`` attributes for a class.

The tuple also allows accessing the fields by their names (see below for
examples).

:param type cls: Class to introspect.

:raise TypeError: If *cls* is not a class.
:raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``
    class.

:rtype: tuple (with name accessors) of `attr.Attribute`

..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields
    by name.
</pre> 
<p class="reference">References <a class="el" href="namespaceattr_1_1__compat.html#a529525094853e4ac7f75fa07e838b749">attr._compat.isclass()</a>.</p>

</div>
</div>
<a id="a5aaa5f8707fabad43bfc9c4e13d06198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaa5f8707fabad43bfc9c4e13d06198">&#9670;&nbsp;</a></span>fields_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.fields_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an ordered dictionary of ``attrs`` attributes for a class, whose
keys are the attribute names.

:param type cls: Class to introspect.

:raise TypeError: If *cls* is not a class.
:raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``
    class.

:rtype: an ordered dict where keys are attribute names and values are
    `attr.Attribute`\\ s. This will be a `dict` if it's
    naturally ordered like on Python 3.6+ or an
    :class:`~collections.OrderedDict` otherwise.

.. versionadded:: 18.1.0
</pre> 
<p class="reference">References <a class="el" href="namespaceattr_1_1__compat.html#a529525094853e4ac7f75fa07e838b749">attr._compat.isclass()</a>, and <a class="el" href="namespaceattr_1_1__compat.html#aa77f00cd859563f6fceb36be818fdcd5">attr._compat.ordered_dict</a>.</p>

</div>
</div>
<a id="a97611bdf2dd52ad5d504c4a08c6c9add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97611bdf2dd52ad5d504c4a08c6c9add">&#9670;&nbsp;</a></span>make_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.make_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bases</em> = <code>(object,)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>attributes_arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A quick way to create a new class called *name* with *attrs*.

:param str name: The name for the new class.

:param attrs: A list of names or a dictionary of mappings of names to
    attributes.

    If *attrs* is a list or an ordered dict (`dict` on Python 3.6+,
    `collections.OrderedDict` otherwise), the order is deduced from
    the order of the names or attributes inside *attrs*.  Otherwise the
    order of the definition of the attributes is used.
:type attrs: `list` or `dict`

:param tuple bases: Classes that the new class will subclass.

:param attributes_arguments: Passed unmodified to `attr.s`.

:return: A new class with *attrs*.
:rtype: type

.. versionadded:: 17.1.0 *bases*
.. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.
</pre> 
<p class="reference">References <a class="el" href="namespaceattr_1_1__make.html#a29239e597ba1943576e22e54ff8c0fba">attr._make.attrib()</a>, and <a class="el" href="namespaceattr_1_1__compat.html#a3e54674bed440a8c1590e96d4d31d76e">attr._compat.new_class</a>.</p>

</div>
</div>
<a id="a82ef7b8b1b1f5d7ddbd625c3b7d2ada9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ef7b8b1b1f5d7ddbd625c3b7d2ada9">&#9670;&nbsp;</a></span>pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.pipe </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>converters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A converter that composes multiple converters into one.

When called on a value, it runs all wrapped converters, returning the
*last* value.

Type annotations will be inferred from the wrapped converters', if
they have any.

:param callables converters: Arbitrary number of converters.

.. versionadded:: 20.1.0
</pre> 
<p class="reference">References <a class="el" href="namespacedotenv_1_1cli.html#ae3c62931683dc637991d815de641a9e6">dotenv.cli.list()</a>.</p>

</div>
</div>
<a id="ae0977efca96d32ec875de623eb6887c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0977efca96d32ec875de623eb6887c3">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def attr._make.validate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validate all attributes on *inst* that have a validator.

Leaves all exceptions through.

:param inst: Instance of a class with ``attrs`` attributes.
</pre> 
<p class="reference">References <a class="el" href="namespaceattr_1_1__make.html#a357e306d8a24fb39dbeebe59d704d352">attr._make.fields()</a>, <a class="el" href="namespacedotenv_1_1cli.html#ae3c62931683dc637991d815de641a9e6">dotenv.cli.list()</a>, and <a class="el" href="namespacepip_1_1__vendor_1_1html5lib_1_1serializer.html#a891d046d68d2a906ab8b95738a4aeccf">pip._vendor.html5lib.serializer.v</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac510a4d2982a3b5968875d946197801c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac510a4d2982a3b5968875d946197801c">&#9670;&nbsp;</a></span>Attribute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def <a class="el" href="classattr_1_1__make_1_1_attribute.html">attr._make.Attribute</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  _add_hash(</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    _add_eq(</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        _add_repr(Attribute, attrs=_a),</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        attrs=[a <span class="keywordflow">for</span> a <span class="keywordflow">in</span> _a <span class="keywordflow">if</span> a.name != <span class="stringliteral">&quot;inherited&quot;</span>],</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ),</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    attrs=[a <span class="keywordflow">for</span> a <span class="keywordflow">in</span> _a <span class="keywordflow">if</span> a.hash <span class="keywordflow">and</span> a.name != <span class="stringliteral">&quot;inherited&quot;</span>],</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3558f3744fa4ca31912898ce1a759969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3558f3744fa4ca31912898ce1a759969">&#9670;&nbsp;</a></span>Factory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def <a class="el" href="classattr_1_1__make_1_1_factory.html">attr._make.Factory</a> = _add_hash(_add_eq(_add_repr(<a class="el" href="classattr_1_1__make_1_1_factory.html">Factory</a>, <a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a>=_f), <a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a>=_f), <a class="el" href="namespaceattr_1_1__make.html#ac47921ac2541011ff8b3acf81c85fd8f">attrs</a>=_f)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b0e597eb2f1bb453e7502bf9e1ec615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0e597eb2f1bb453e7502bf9e1ec615">&#9670;&nbsp;</a></span>NOTHING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._make.NOTHING = <a class="el" href="classattr_1_1__make_1_1___nothing.html">_Nothing</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceattr.html">attr</a></li><li class="navelem"><a class="el" href="namespaceattr_1_1__make.html">_make</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
